{"version":3,"file":"static/js/328.7305d138.chunk.js","mappings":"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","sources":["workers/sedentarismTest.js","workers/fullnessWorker.js","workers/circadianTest.js"],"sourcesContent":["// Function to calculate Sedentarism Factor with dynamic variation\n// Utility function for generating biased random variation\nconst addBiasedVariation = (value, percentage = 0.1, upwardBias = 0.8) => {\n    // Generate a biased random number: 60% chance for positive variation\n    const bias = Math.random() < upwardBias ? 1 : -1;\n    const variation = bias * Math.random() * percentage * value;\n    return Math.max(0.2, value + variation); // Ensure it doesn't go below the minimum sedentarism level\n  };\n  \n  \n  // Function to calculate Sedentarism Factor with dynamic and realistic variation\n  export const calculateSedentarismFactor = (\n    simulationHour,\n    fullSedentarismStartHour = 23,\n    fullSedentarismEndHour = 7\n  ) => {\n    const TRANSITION_LENGTH = Math.random() * 0.5 + 1.5; // Random between 1.5 and 2 hours\n  \n    // Activity levels\n    const SLEEP_LEVEL = 1.0; // Completely sedentary while sleeping\n    const MIN_LEVEL = 0.2; // Most active during day\n  \n    const hour24 = convertTo24Hour(simulationHour);\n    let factor;\n  \n    // Deep sleep period (full sedentarism)\n    if ((hour24 >= fullSedentarismStartHour) || (hour24 < fullSedentarismEndHour)) {\n      factor = SLEEP_LEVEL; // Static for sleep\n    }\n    // Morning transition (waking up)\n    else if (hour24 < (fullSedentarismEndHour + TRANSITION_LENGTH)) {\n      const progress = (hour24 - fullSedentarismEndHour) / TRANSITION_LENGTH;\n      factor = SLEEP_LEVEL - (SLEEP_LEVEL - MIN_LEVEL) * Math.pow(progress, 2);\n      factor = addBiasedVariation(factor, 0.13, 0.58); // Smaller variation during transition\n    }\n    // Evening transition (getting ready for sleep)\n    else if (hour24 >= (fullSedentarismStartHour - TRANSITION_LENGTH)) {\n      const progress = (fullSedentarismStartHour - hour24) / TRANSITION_LENGTH;\n      factor = SLEEP_LEVEL - (SLEEP_LEVEL - MIN_LEVEL) * Math.pow(progress, 2);\n      factor = addBiasedVariation(factor, 0.15, 0.25); // Smaller variation during transition\n    }\n    // Active day period\n    else {  \n      factor = MIN_LEVEL;\n      factor = addBiasedVariation(factor, 1.5, 0.88); // Larger variation with upward bias during active periods\n    }\n  \n    return factor;\n  };\n\n  \n// Utility function to convert AM/PM time format to 24-hour format\nexport const convertTo24Hour = (timeString) => {\n    const [time, modifier] = timeString.split(\" \");\n    let [hours, minutes] = time.split(\":\").map(Number);\n  \n    if (modifier === \"PM\" && hours !== 12) {\n      hours += 12; // Add 12 for PM hours except 12 PM\n    } else if (modifier === \"AM\" && hours === 12) {\n      hours = 0; // Midnight case (12 AM is 0:00)\n    }\n  \n    return hours + minutes / 60; // Convert to fractional hour (e.g., 1:30 = 1.5)\n  };\n\n\n// // Only run analysis if we're in Node.js environment\n// if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n//     const fs = require('fs');\n    \n//     // Initialize output\n//     let output = `SEDENTARISM FACTOR THROUGHOUT THE DAY\n// =====================================\n// Sleep Period: 23:00 - 07:00\n// Maximum Sedentarism: 1.0 (deep sleep)\n// Minimum Sedentarism: 0.2 (active day)\n// Transition: Variable (1.5-2 hours), Exponential curve\n\n// Hour-by-Hour Analysis:\n// ----------------------------------------\\n\\n`;\n\n//     // Calculate for each hour with 15-minute intervals\n//     const hoursToShow = [];\n//     for (let hour = 0; hour < 24; hour++) {\n//         for (let fraction = 0; fraction <= 0.75; fraction += 0.25) {\n//             hoursToShow.push(hour + fraction);\n//         }\n//     }\n\n//     hoursToShow.forEach(hour => {\n//         const factor = calculateSedentarismFactor(hour);\n//         const wholeHour = Math.floor(hour);\n//         const minutes = Math.round((hour - wholeHour) * 60);\n//         const timeStr = `${wholeHour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n        \n//         // Determine period type based on time\n//         let periodType;\n//         const hour24 = (wholeHour + (minutes / 60)) % 24;\n//         if ((hour24 >= 23) || (hour24 < 7)) {\n//             periodType = \"Sleep Period\";\n//         } else if ((hour24 >= 7 && hour24 < 9) || (hour24 >= 21 && hour24 < 23)) {\n//             periodType = \"Transition Period\";\n//         } else {\n//             periodType = \"Active Period\";\n//         }\n        \n//         // Create visual representation\n//         // Scale factor from 0.2 to 1.0 to 0 to 40 for bar display\n//         const barLength = Math.round((factor - 0.2) * 50);\n//         const bar = '█'.repeat(barLength) + '░'.repeat(40 - barLength);\n        \n//         // Calculate percentage of max sedentarism\n//         const percentSedentary = ((factor - 0.2) * 1.25).toFixed(1);\n        \n//         output += `${timeStr} | ${factor.toFixed(3)} (${percentSedentary}%) ${bar} | ${periodType}\\n`;\n//     });\n\n//     // Add explanation\n//     output += `\\nLegend:\n// ----------------------------------------\n// █ = Sedentarism Level (longer bar = more sedentary)\n// Sleep Level: 1.000 (complete sedentarism during deep sleep)\n// Active Level: 0.200 (minimum sedentarism during day)\n\n// Key Periods:\n// - Sleep Start: 23:00 (11:00 PM)\n// - Sleep End: 07:00 (7:00 AM)\n// - Transition Length: 1.5-2 hours (randomized)\n\n// Notes:\n// - Uses exponential curves for natural transitions\n// - Highest sedentarism during deep sleep\n// - Gradual wake-up and wind-down periods\n// - Most active during day\\n`;\n\n//     // Write results to file\n//     fs.writeFileSync('sedentarism_analysis.txt', output);\n//     console.log('Sedentarism analysis has been written to sedentarism_analysis.txt');\n// }\n\n// // Export for both environments\n// if (typeof module !== 'undefined' && module.exports) {\n//     module.exports = { calculateSedentarismFactor };\n// } else {\n//     window.calculateSedentarismFactor = calculateSedentarismFactor;\n// }","// src/workers/fullnessWorker.js\n// Run simulation every simulationSpeed ms. Together with function_time_scale, it will give rise to simulation speed compared to Reality.\n// Eg. Match Reality with 0.2s simulation run speed. 5.555555555555556e-5;\n// Eg. Advance time by 0.01*h(hours). Simulating per 0.1 seconds (current simulation time dimension), 5x Reality\n// a 0.01*h increase = 36 secondds, 36x Reality\n// To Match reality, no need to infere simulation speed, as this is kept for offering graph Flow, But can match it using function_time_scale variable. In this example, it would mean decreasing 0.01 by (5x36)\n// Function to calculate meal contribution using exponential decay\n\n// src/workers/fullnessWorker.js\n\nimport { calculateCircadianFactor } from './circadianTest.js';\nimport { calculateSedentarismFactor } from './sedentarismTest.js';\n\nlet currentArchetype = null; // Global variable to store the current archetype\nlet time = 0;\nlet fullness = 0;\nlet meals = []; // Store meal data\nconst simulationSpeed = 100; // Interval in ms for simulation updates\nlet functionTimeScale = 0.1; // Initial time scale for simulation (controls speed relative to reality)\nlet speedMultiplier = 1; // Default speed multiplier\n\nlet isPaused = false;\nlet intervalId = null; // To store the interval ID\n\nconst calculateMealContribution = (beta, timeDifference, simulationHour, fullSedentarismStartHour, fullSedentarismEndHour, mealId) => {\n  const k = 0.27; // Base decay constant\n\n  // Get modifiers\n  const circadianFactor = calculateCircadianFactor(simulationHour);\n  const sedentarismFactor = calculateSedentarismFactor(simulationHour, fullSedentarismStartHour, fullSedentarismEndHour);\n\n  // Sedentarism impact on digestion\n  const sedentarismImpact = 1.3 - 0.5 * sedentarismFactor;\n  const modifiedK = k * circadianFactor * sedentarismImpact;\n\n  // Calculate base contribution\n  let contribution = beta * Math.exp(-modifiedK * timeDifference);\n\n  // Debugging output\n  console.log(\n    `dodo Meal ${mealId} at time ${simulationHour}: \n    Circadian Factor: ${circadianFactor.toFixed(3)}, \n    Sedentarism Factor: ${sedentarismFactor.toFixed(3)}, \n    Modified Decay (k): ${modifiedK.toFixed(3)}, \n    Contribution: ${contribution.toFixed(3)}`\n  );\n\n  return contribution;\n};\n\n// Function to update fullness and time\nfunction updateFullness() {\n  if (isPaused) {\n    return; // Do not proceed if paused\n  }\n\n  // Scale time increment based on functionTimeScale and speedMultiplier\n  time = +(time + functionTimeScale).toFixed(5); // Advance time based on the scaled time\n  console.log(\"Current Time (Worker Hour):\", time);\n\n  // Calculate the current simulation time\n  const workerSimulationTime = calculateSimulationTime(time);\n  console.log(`[worker] Current ${currentArchetype.name} Simulation Time:`, workerSimulationTime);\n\n  // Remove meals older than 12 simulated hours\n  meals = meals.filter(meal => (time - meal.timeEaten) < 12);\n\n  // Calculate fullness as the sum of all meal contributions\n  let newFullness = 0;\n  meals.forEach((meal, index) => {\n    const timeDifference = (time - meal.timeEaten);\n    if (timeDifference > 0) {\n      const contribution = calculateMealContribution(\n        meal.beta,\n        timeDifference,\n        workerSimulationTime, // Current simulation hour XX:XX AM/PM format\n        currentArchetype.fullSedentarismStartHour,\n        currentArchetype.fullSedentarismEndHour,\n        index\n      );\n      newFullness += contribution;\n      console.log(`Meal ${index + 1} at time (hour) ${meal.timeEaten} contributes ${contribution.toFixed(3)} to fullness.`);\n    }\n  });\n\n  // Cap fullness at 1\n  fullness = Math.min(newFullness, 1);\n  console.log(\"Calculated Fullness:\", fullness);\n\n  // Send the updated time and fullness back to the main thread\n  postMessage({ type: 'UPDATE_DATA', time, fullness, data: meals });\n}\n\n// Function to calculate the current simulation time in AM/PM format\nfunction calculateSimulationTime(time) {\n  const startHour = 6; // Simulation starts at 6AM\n  const totalHours = (startHour + time) % 24; // Total simulation time in 24-hour format\n\n  const hour = Math.floor(totalHours); // Extract the integer hour\n  const minutes = Math.floor((totalHours % 1) * 60); // Extract minutes from the fractional part\n  const formattedHour = hour % 12 || 12; // Convert 24-hour format to 12-hour format\n  const isPM = hour >= 12; // Determine AM/PM\n  const formattedMinutes = minutes.toString().padStart(2, '0'); // Pad minutes with leading zero\n\n  return `${formattedHour}:${formattedMinutes} ${isPM ? 'PM' : 'AM'}`;\n}\n\n\n// Function to start the simulation interval\nfunction startSimulation() {\n  if (!intervalId) { // Prevent multiple intervals\n    intervalId = setInterval(updateFullness, simulationSpeed);\n    console.log('Worker simulation started.');\n  }\n}\n\n// Function to stop the simulation interval\nfunction stopSimulation() {\n  if (intervalId) {\n    clearInterval(intervalId);\n    intervalId = null;\n    console.log('Worker simulation stopped.');\n  }\n}\n\n// Start the simulation initially\nstartSimulation();\n\n// Listen for messages from the main thread (e.g., to add meals, reset, pause, resume, set speed)\nonmessage = function(e) {\n  const { type, amount, multiplier, data } = e.data;\n\n  if (type === 'ADD_MEAL') {\n    meals.push({ beta: amount, timeEaten: time });\n    console.log(`Meal added: beta=${amount}, timeEaten=${time}`);\n  } else if (type === 'RESET') {\n    time = 0;\n    fullness = 0;\n    meals = [];\n    postMessage({ type: 'RESET_COMPLETE' });\n    console.log('Worker reset.');\n  } else if (type === 'PAUSE') {\n    console.log('Worker PAUSED!');\n    isPaused = true;\n    stopSimulation(); // Stop the interval when paused\n  } else if (type === 'RESUME') {\n    isPaused = false;\n    startSimulation(); // Restart the interval when resumed\n    console.log('Worker resumed.');\n  } else if (type === 'SET_SPEED') {\n    // Adjust functionTimeScale based on the new multiplier\n    speedMultiplier = multiplier / 3600; // Normalize value\n    const computing_offset = 0 // Computation offset to balance time speed to 100 ms initially\n    functionTimeScale = 0.1 / speedMultiplier - computing_offset; // Update time scale based on speed multiplier\n    console.log(`Updated simulation speed: multiplier=${speedMultiplier}, functionTimeScale=${functionTimeScale}`);\n  }\n else if (type === 'INITIALIZE_ARCHETYPE') {\n  // Unpack and log the archetype object for testing\n  currentArchetype = data;\n  console.log('Worker received workerArchetype:', data);\n }\n};","// This is aproximately defined to a ~14-15 hour day, \n// and can be specifically updated as per season (API call or reading date from the system)\n\nimport { convertTo24Hour } from \"./sedentarismTest\";\nexport const calculateCircadianFactor = (simulationHour) => {\n    const START_HOUR = 3.5;      // 03:30 AM - Metabolism begins rising\n    const PEAK_HOUR = 14;        // 02:00 PM - Peak metabolic activity\n    const END_HOUR = 23;         // 11:00 PM - Return to base level\n    \n    const BASE_LEVEL = 0.8;      // Minimum metabolic rate\n    const PEAK_LEVEL = 1.2;      // Maximum metabolic rate\n    \n    // Handle day wrapping\n    let adjustedHour = convertTo24Hour(simulationHour);\n\n    // Calculate position in the cycle\n    let cyclePosition;\n    if (adjustedHour >= START_HOUR && adjustedHour <= END_HOUR) {\n        // Active phase\n        const totalActiveHours = END_HOUR - START_HOUR;\n        const peakPosition = (PEAK_HOUR - START_HOUR) / totalActiveHours;\n        const currentPosition = (adjustedHour - START_HOUR) / totalActiveHours;\n        \n        // Create a smooth curve that peaks at PEAK_HOUR\n        cyclePosition = Math.sin(currentPosition * Math.PI);\n        \n        // Adjust the curve to peak at the correct time\n        if (currentPosition <= peakPosition) {\n            cyclePosition = cyclePosition * (currentPosition / peakPosition);\n        } else {\n            cyclePosition = cyclePosition * (1 - (currentPosition - peakPosition) / (1 - peakPosition));\n        }\n    } else {\n        // Inactive phase - maintain base level\n        cyclePosition = 0;\n    }\n    \n    // Scale between BASE_LEVEL and PEAK_LEVEL\n    return BASE_LEVEL + (PEAK_LEVEL - BASE_LEVEL) * cyclePosition;\n};\n\n\n// // Only run analysis if we're in Node.js environment\n// if (typeof process !== 'undefined' && process.versions && process.versions.node) {\n//     const fs = require('fs');\n    \n//     // Initialize output\n//     let output = `CIRCADIAN RHYTHM ANALYSIS\n// =======================\n// Base Metabolism: 0.8 (80% of normal)\n// Peak Metabolism: 1.2 (120% of normal)\n// Start Time: 03:30 AM\n// Peak Time: 14:00 (2:00 PM)\n// End Time: 23:00 (11:00 PM)\n\n// Hour-by-Hour Analysis:\n// ----------------------------------------\\n\\n`;\n\n//     // Calculate for each hour with 15-minute intervals\n//     const hoursToShow = [];\n//     for (let hour = 0; hour < 24; hour++) {\n//         for (let fraction = 0; fraction <= 0.75; fraction += 0.25) {\n//             hoursToShow.push(hour + fraction);\n//         }\n//     }\n\n//     hoursToShow.forEach(hour => {\n//         const factor = calculateCircadianFactor(hour);\n//         const wholeHour = Math.floor(hour);\n//         const minutes = Math.round((hour - wholeHour) * 60);\n//         const timeStr = `${wholeHour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n        \n//         // Determine period type based on metabolic rate\n//         let periodType = \"Normal Metabolism\";\n//         if (factor > 1.1) {\n//             periodType = \"Peak Metabolism\";\n//         } else if (factor < 0.9) {\n//             periodType = \"Low Metabolism\";\n//         }\n        \n//         // Calculate percentage difference from baseline\n//         const percentChange = ((factor - 1) * 100).toFixed(1);\n//         const changeStr = (percentChange >= 0 ? '+' : '') + percentChange + '%';\n        \n//         // Create visual representation\n//         // Scale factor from 0.8 to 1.2 to 0 to 40 for bar display\n//         const barLength = Math.round((factor - 0.8) * 100);\n//         const bar = '█'.repeat(barLength) + '░'.repeat(40 - barLength);\n        \n//         output += `${timeStr} | ${factor.toFixed(3)} (${changeStr}) ${bar} | ${periodType}\\n`;\n//     });\n\n//     // Add explanation\n//     output += `\\nLegend:\n// ----------------------------------------\n// █ = Metabolic Rate (longer bar = higher metabolism)\n// Base Rate: 0.800 (80% metabolism before 3:30 AM and after 11:00 PM)\n// Peak: ~1.200 (+20% around 2:00 PM)\n// Low: ~0.800 (-20% during night hours)\n\n// Key Periods:\n// - Night/Early Morning (00:00-03:30): Base metabolism\n// - Rising Phase (03:30-14:00): Gradually increasing metabolism\n// - Peak Period (around 14:00): Maximum metabolic rate\n// - Declining Phase (14:00-23:00): Gradually decreasing metabolism\n// - Night Phase (23:00-00:00): Return to base metabolism\n\n// Formula uses modified sine curves for smooth transitions between:\n// 1. Base level (0.8) at 03:30\n// 2. Peak level (1.2) at 14:00\n// 3. Return to base level (0.8) at 23:00\\n`;\n\n//     // Write results to file\n//     fs.writeFileSync('circadian_analysis.txt', output);\n//     console.log('Circadian rhythm analysis has been written to circadian_analysis.txt');\n// }\n\n// // Export for both environments\n// if (typeof module !== 'undefined' && module.exports) {\n//     module.exports = { calculateCircadianFactor };\n// } else {\n//     window.calculateCircadianFactor = calculateCircadianFactor;\n// }\n\n"],"names":["addBiasedVariation","value","percentage","arguments","length","undefined","upwardBias","variation","Math","random","max","convertTo24Hour","timeString","time","modifier","split","hours","minutes","map","Number","currentArchetype","fullness","meals","functionTimeScale","speedMultiplier","isPaused","intervalId","calculateMealContribution","beta","timeDifference","simulationHour","fullSedentarismStartHour","fullSedentarismEndHour","mealId","circadianFactor","START_HOUR","cyclePosition","adjustedHour","totalActiveHours","END_HOUR","peakPosition","currentPosition","sin","PI","calculateCircadianFactor","sedentarismFactor","TRANSITION_LENGTH","hour24","factor","progress","pow","calculateSedentarismFactor","modifiedK","contribution","exp","console","log","toFixed","updateFullness","workerSimulationTime","totalHours","hour","floor","formattedHour","isPM","formattedMinutes","toString","padStart","calculateSimulationTime","name","filter","meal","timeEaten","newFullness","forEach","index","min","postMessage","type","data","startSimulation","setInterval","onmessage","e","amount","multiplier","push","clearInterval"],"sourceRoot":""}